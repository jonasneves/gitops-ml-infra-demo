name: GitOps Infrastructure Demo

on:
  schedule:
    # Run daily at 9:00 AM UTC (adjust timezone as needed)
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      demo_mode:
        description: 'Demo mode (full or quick)'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - quick

# Cancel in-progress runs when a new one starts
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  ARGOCD_VERSION: v2.9.3
  REGISTRY: ghcr.io

jobs:
  # Job 1: Build Docker image (runs first, independently)
  build:
    name: Build ML Inference Image
    runs-on: ubuntu-22.04
    timeout-minutes: 10

    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/ml-inference
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=branch
            type=ref,event=pr
            latest

      - name: Build and push ML inference image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app/ml-inference
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build complete
        run: |
          echo "[✓] Docker image built and pushed successfully"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  # Job 2: Deploy infrastructure (depends on build)
  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    needs: build

    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: Verify cluster
        run: |
          echo "=== Cluster Info ==="
          kubectl cluster-info
          kubectl version

          echo -e "\n=== Nodes ==="
          kubectl get nodes -o wide

          echo -e "\n=== System Pods ==="
          kubectl get pods -n kube-system

      - name: Install ArgoCD
        run: |
          echo "Installing ArgoCD ${{ env.ARGOCD_VERSION }}..."

          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml

          echo "Waiting for ArgoCD pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-repo-server -n argocd --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s

          echo "[✓] ArgoCD installed successfully"

      - name: Get ArgoCD credentials
        id: argocd-creds
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV
          echo "[✓] ArgoCD credentials retrieved"

      - name: Expose ArgoCD server
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5
          echo "[✓] ArgoCD UI accessible at https://localhost:8080"

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/
          argocd version --client

      - name: Login to ArgoCD
        run: |
          argocd login localhost:8080 \
            --username admin \
            --password $ARGOCD_PASSWORD \
            --insecure
          echo "[✓] Logged in to ArgoCD"

      - name: Register Git repository with ArgoCD
        run: |
          echo "Registering repository with ArgoCD..."

          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "[✓] Repository registered with ArgoCD"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Docker image in Minikube
        run: |
          echo "Pulling Docker image from GHCR..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Loading image into Minikube..."
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Verifying image in Minikube..."
          minikube image ls | grep ml-inference

          echo "[✓] Docker image loaded into Minikube"

      - name: Create namespaces
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true
          echo "[✓] Namespaces created"

      - name: Deploy ML Inference via ArgoCD
        run: |
          echo "Creating ML Inference application..."

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true

          echo "[✓] ML Inference application created"

      - name: Deploy Observability Stack via ArgoCD
        run: |
          echo "Creating Observability application..."

          argocd app create observability \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/observability \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace monitoring \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true

          echo "[✓] Observability application created"

      - name: Wait for applications to sync
        run: |
          echo "Waiting for applications to sync..."

          # Give ArgoCD a moment to detect the apps
          sleep 5

          # Manually trigger sync to ensure it starts
          echo "Triggering manual sync for ml-inference..."
          argocd app sync ml-inference --prune || true

          echo "Triggering manual sync for observability..."
          argocd app sync observability --prune || true

          # Wait for health with timeout
          echo "Waiting for ml-inference to be healthy..."
          argocd app wait ml-inference --timeout 180 --health || {
            echo "[!] ml-inference did not become healthy in time"
            argocd app get ml-inference
          }

          echo "Waiting for observability to be healthy..."
          argocd app wait observability --timeout 180 --health || {
            echo "[!] observability did not become healthy in time"
            argocd app get observability
          }

          echo "[✓] Applications sync attempted"

      - name: Verify ArgoCD applications
        run: |
          echo "=== ArgoCD Applications ==="
          argocd app list

          echo -e "\n=== ML Inference App Details ==="
          argocd app get ml-inference

          echo -e "\n=== Observability App Details ==="
          argocd app get observability

      - name: Verify Kubernetes resources
        run: |
          echo "=== All Namespaces ==="
          kubectl get namespaces

          echo -e "\n=== ML Inference Namespace ==="
          kubectl get all -n ml-inference

          echo -e "\n=== Monitoring Namespace ==="
          kubectl get all -n monitoring

          echo -e "\n=== ML Inference Pods ==="
          kubectl get pods -n ml-inference -o wide

      - name: Save cluster state
        run: |
          mkdir -p /tmp/cluster-state

          # Save kubeconfig
          kubectl config view --raw > /tmp/cluster-state/kubeconfig

          # Save ArgoCD password
          echo $ARGOCD_PASSWORD > /tmp/cluster-state/argocd-password

          # Save cluster info
          kubectl cluster-info > /tmp/cluster-state/cluster-info.txt
          kubectl get all --all-namespaces > /tmp/cluster-state/all-resources.txt

      - name: Upload cluster state
        uses: actions/upload-artifact@v4
        with:
          name: cluster-state
          path: /tmp/cluster-state/
          retention-days: 1

      - name: Deployment complete
        run: |
          echo "[✓] Infrastructure deployed successfully"
          echo "   - Minikube cluster running"
          echo "   - ArgoCD installed and configured"
          echo "   - ML Inference service deployed"
          echo "   - Observability stack deployed"

  # Job 3a: Run tests (depends on deploy, runs in parallel with demo)
  test:
    name: Run Health Checks & Tests
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: deploy

    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download cluster state
        uses: actions/download-artifact@v4
        with:
          name: cluster-state
          path: /tmp/cluster-state/

      - name: Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: Restore cluster state
        run: |
          # Wait for cluster to be ready
          kubectl wait --for=condition=ready node --all --timeout=300s

          echo "Note: Running tests on fresh cluster (cluster state is reference only)"

      - name: Re-install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: Get ArgoCD credentials
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

      - name: Login to ArgoCD
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5
          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

      - name: Register Git repository with ArgoCD
        run: |
          echo "Registering repository with ArgoCD..."

          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "[✓] Repository registered with ArgoCD"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Docker image in Minikube
        run: |
          echo "Pulling Docker image from GHCR..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Loading image into Minikube..."
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Verifying image in Minikube..."
          minikube image ls | grep ml-inference

          echo "[✓] Docker image loaded into Minikube"

      - name: Deploy applications
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune

          argocd app wait ml-inference --timeout 300 --health || true

      - name: Run health checks
        run: |
          echo "Waiting for ML inference pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=ml-inference -n ml-inference --timeout=180s

          echo -e "\n=== Testing ML Inference Service ==="

          # Port forward the service
          kubectl port-forward -n ml-inference svc/ml-inference 8000:80 > /dev/null 2>&1 &
          PF_PID=$!
          sleep 5

          # Health check
          echo "Testing /health endpoint..."
          curl -f http://localhost:8000/health | jq .

          # Readiness check
          echo -e "\nTesting /ready endpoint..."
          curl -f http://localhost:8000/ready | jq .

          # Inference test
          echo -e "\nTesting /predict endpoint..."
          curl -f -X POST http://localhost:8000/predict \
            -H "Content-Type: application/json" \
            -d '{"text": "This GitOps demo is amazing!"}' | jq .

          # Batch inference test
          echo -e "\nTesting /predict/batch endpoint..."
          curl -f -X POST http://localhost:8000/predict/batch \
            -H "Content-Type: application/json" \
            -d '{"texts": ["Great work!", "This is terrible", "Just okay"]}' | jq .

          # Metrics check
          echo -e "\nTesting /metrics endpoint..."
          curl -f http://localhost:8000/metrics | grep -E "^inference_" | head -10

          kill $PF_PID || true

          echo -e "\n[✓] All health checks passed!"

      - name: Collect test metrics
        if: always()
        run: |
          mkdir -p /tmp/test-results

          # Get pod status
          kubectl get pods -n ml-inference -o yaml > /tmp/test-results/pod-status.yaml

          # Get pod logs
          kubectl logs -n ml-inference -l app=ml-inference --tail=100 > /tmp/test-results/ml-inference.log || true

          # Get events
          kubectl get events -n ml-inference --sort-by='.lastTimestamp' > /tmp/test-results/events.txt

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: /tmp/test-results/
          retention-days: 30

      - name: Tests complete
        run: |
          echo "[✓] All tests passed successfully!"

  # Job 3b: GitOps self-healing demo (depends on deploy, runs in parallel with test)
  demo:
    name: GitOps Self-Healing Demo
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: deploy
    if: github.event.inputs.demo_mode == 'full' || github.event_name == 'workflow_dispatch'

    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096

      - name: Install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: Setup ArgoCD
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"

          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5

          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

      - name: Register Git repository with ArgoCD
        run: |
          echo "Registering repository with ArgoCD..."

          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "[✓] Repository registered with ArgoCD"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Docker image in Minikube
        run: |
          echo "Pulling Docker image from GHCR..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Loading image into Minikube..."
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Verifying image in Minikube..."
          minikube image ls | grep ml-inference

          echo "[✓] Docker image loaded into Minikube"

      - name: Deploy ML Inference
        run: |
          kubectl create namespace ml-inference

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune

          argocd app wait ml-inference --timeout 300 --health || true

      - name: Demonstrate GitOps self-healing
        run: |
          echo "=== Demonstrating GitOps Self-Healing ==="

          echo -e "\n1. Current state (from Git):"
          ORIGINAL_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $ORIGINAL_REPLICAS"

          echo -e "\n2. Manually scaling deployment (simulating drift)..."
          kubectl scale deployment ml-inference -n ml-inference --replicas=5
          sleep 3

          echo -e "\n3. Deployment now has:"
          DRIFTED_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $DRIFTED_REPLICAS"

          echo -e "\n4. ArgoCD detects drift..."
          argocd app get ml-inference | grep -A 5 "Sync Status"

          echo -e "\n5. Waiting for ArgoCD to self-heal (sync back to Git state)..."
          sleep 30

          echo -e "\n6. After self-healing:"
          HEALED_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $HEALED_REPLICAS"

          if [ "$HEALED_REPLICAS" -eq "$ORIGINAL_REPLICAS" ]; then
            echo -e "\n[✓] GitOps self-healing successful!"
          else
            echo -e "\n[!] Self-healing still in progress..."
          fi

      - name: Capture demo artifacts
        if: always()
        run: |
          mkdir -p /tmp/demo-artifacts

          argocd app get ml-inference -o json > /tmp/demo-artifacts/ml-inference.json || true
          argocd app history ml-inference > /tmp/demo-artifacts/ml-inference-history.txt || true
          kubectl get events -n ml-inference --sort-by='.lastTimestamp' > /tmp/demo-artifacts/events.txt || true
          kubectl describe deployment ml-inference -n ml-inference > /tmp/demo-artifacts/deployment-describe.txt || true

      - name: Upload demo artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: demo-artifacts
          path: /tmp/demo-artifacts/
          retention-days: 30

      - name: Demo complete
        run: |
          echo "[✓] GitOps self-healing demonstration complete!"

  # Job 4: Live Dashboard (runs in parallel, provides public URL)
  dashboard:
    name: Live Dashboard
    runs-on: ubuntu-22.04
    timeout-minutes: 25
    needs: build

    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install flask flask-cors
          echo "[✓] Python dependencies installed"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: Verify cluster
        run: |
          echo "=== Cluster Ready ==="
          kubectl cluster-info
          kubectl get nodes
          echo "[✓] Cluster is ready"

      - name: Load Docker image
        run: |
          echo "Pulling and loading ML inference image..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest
          echo "[✓] Image loaded into Minikube"

      - name: Install ArgoCD
        run: |
          echo "Installing ArgoCD..."
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          echo "[✓] ArgoCD installed"

      - name: Setup ArgoCD
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

          # Install ArgoCD CLI
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

          # Port forward ArgoCD
          kubectl port-forward svc/argocd-server -n argocd 8081:443 > /dev/null 2>&1 &
          sleep 5

          # Login and register repository
          argocd login localhost:8081 --username admin --password $ARGOCD_PASSWORD --insecure
          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "[✓] ArgoCD configured"

      - name: Setup dashboard server
        run: |
          cp scripts/dashboard_server.py /tmp/dashboard_server.py
          echo "[✓] Dashboard server ready"

      - name: Start dashboard server
        run: |
          python3 /tmp/dashboard_server.py > /tmp/dashboard.log 2>&1 &
          sleep 3
          curl -f http://localhost:8080/ > /dev/null && echo "[✓] Dashboard running on port 8080" || {
            echo "[X] Dashboard failed to start!"
            echo "=== Python file content (first 50 lines) ==="
            head -50 /tmp/dashboard_server.py | cat -A
            echo ""
            echo "=== Dashboard error logs ==="
            cat /tmp/dashboard.log
            exit 1
          }

      - name: Deploy applications
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated --self-heal --auto-prune || echo "App exists"

          argocd app create observability \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/observability \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace monitoring \
            --sync-policy automated --self-heal --auto-prune || echo "App exists"

          echo "[✓] Applications created"

      - name: Install Cloudflare Tunnel
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          chmod +x cloudflared-linux-amd64
          sudo mv cloudflared-linux-amd64 /usr/local/bin/cloudflared
          cloudflared version

      - name: Start Cloudflare Tunnel
        env:
          TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          echo "================================================"
          echo "STARTING LIVE GITOPS DASHBOARD"
          echo "================================================"

          # Create tunnel credentials file
          mkdir -p ~/.cloudflared
          echo "$TUNNEL_TOKEN" > ~/.cloudflared/tunnel-token.json

          # Start named tunnel
          cloudflared tunnel --credentials-file ~/.cloudflared/tunnel-token.json run gitops-demo > /tmp/cf-dashboard.log 2>&1 &
          sleep 10

          echo ""
          echo "================================================"
          echo "LIVE DASHBOARD URL:"
          echo "================================================"
          echo "https://gitops-infra.neevs.io"
          echo "================================================"
          echo ""
          echo "Dashboard will remain open for 15 minutes"
          echo "   Watch your GitOps deployment in real-time!"
          echo ""

          # Keep tunnel alive
          sleep 900  # 15 minutes

      - name: Final status
        if: always()
        run: |
          echo "=== Final Status ==="
          argocd app list || true
          kubectl get all -n ml-inference || true
          echo "[✓] Dashboard session complete"

  # Job 5: Generate report (depends on all jobs, always runs)
  report:
    name: Generate Final Report
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    needs: [build, deploy, test, demo, dashboard]
    if: always()

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: /tmp/artifacts/

      - name: Generate demo report
        run: |
          mkdir -p /tmp/final-report

          cat > /tmp/final-report/DEMO-REPORT.md << 'EOFF'
          # GitOps Infrastructure Demo Report

          ## Demonstration Summary

          This workflow successfully demonstrated:

          - [✓] **Docker Build & Push** - ML inference image built and pushed to GHCR
          - [✓] **ArgoCD GitOps deployment** - Declarative, Git-driven infrastructure
          - [✓] **Kubernetes orchestration** - Multi-service deployment on Minikube
          - [✓] **ML Model Serving** - FastAPI inference service with sentiment analysis
          - [✓] **Observability Stack** - VictoriaMetrics and Grafana for monitoring
          - [✓] **Health checks** - All services passed liveness and readiness probes
          - [✓] **Self-healing** - ArgoCD automatic drift detection and correction

          ## Workflow Results

          EOFF

          # Add build status
          echo "### Build Status" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Build job: ${{ needs.build.result }}" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Deploy job: ${{ needs.deploy.result }}" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Test job: ${{ needs.test.result }}" >> /tmp/final-report/DEMO-REPORT.md

          # Add timing information
          cat >> /tmp/final-report/DEMO-REPORT.md << 'EOFF'

          ## Key Takeaways

          1. **Parallelized Workflow**: Build, test, and demo jobs run efficiently
          2. **GitOps in Action**: All deployments managed through Git with ArgoCD
          3. **Production Patterns**: Health checks, resource limits, auto-scaling ready
          4. **Observable**: VictoriaMetrics metrics, application logs, K8s events
          5. **Self-healing**: Demonstrated automatic drift correction
          6. **Zero Cost**: Entire demo runs in GitHub Actions (no cloud account needed)

          ## Architecture

          ```
          GitHub Actions Workflow
          │
          ├── Job 1: Build
          │   └── Docker image → GHCR
          │
          ├── Job 2: Deploy [depends on Build]
          │   ├── Minikube cluster
          │   ├── ArgoCD installation
          │   └── Application deployment
          │
          ├── Job 3a: Test [parallel, depends on Deploy]
          │   └── Health checks & API tests
          │
          ├── Job 3b: Demo [parallel, depends on Deploy]
          │   └── GitOps self-healing demo
          │
          └── Job 4: Report [depends on all]
              └── Aggregate results & artifacts
          ```

          ## Technologies Demonstrated

          - **GitOps**: ArgoCD for declarative deployments
          - **Kubernetes**: Container orchestration
          - **CI/CD**: GitHub Actions with job parallelization
          - **ML Ops**: FastAPI model serving
          - **Observability**: VictoriaMetrics + Grafana
          - **Python**: FastAPI application
          - **Docker**: Container packaging & GHCR

          ---

          **Duration**: ~10-15 minutes (with parallelization)
          **Cost**: $0 (GitHub Actions free tier)
          **Reproducible**: [✓] Anyone can run this workflow
          EOFF

          cat /tmp/final-report/DEMO-REPORT.md

      - name: Upload final report
        uses: actions/upload-artifact@v4
        with:
          name: final-demo-report
          path: /tmp/final-report/
          retention-days: 30

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('/tmp/final-report/DEMO-REPORT.md', 'utf8');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## GitOps Demo Results\n\n${report}\n\n[View full artifacts](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
            });

      - name: Report complete
        run: |
          echo "╔════════════════════════════════════════════╗"
          echo "║                                            ║"
          echo "║   GitOps Infrastructure Demo Complete      ║"
          echo "║                                            ║"
          echo "║   Workflow Summary:                        ║"
          echo "║   - Build: ${{ needs.build.result }}"
          echo "║   - Deploy: ${{ needs.deploy.result }}"
          echo "║   - Test: ${{ needs.test.result }}"
          echo "║                                            ║"
          echo "║   Download artifacts for full details      ║"
          echo "║                                            ║"
          echo "╚════════════════════════════════════════════╝"
