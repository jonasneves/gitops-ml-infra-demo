name: üé≠ Live GitOps Dashboard

on:
  workflow_dispatch:
    inputs:
      duration:
        description: 'Keep dashboard open (minutes)'
        required: false
        default: '20'
        type: string

jobs:
  live-dashboard:
    name: üé¨ GitOps Theater Mode
    runs-on: ubuntu-22.04
    timeout-minutes: 35

    permissions:
      contents: read
      packages: write

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Install Python dependencies
        run: |
          pip install flask flask-cors
          echo "‚úÖ Python dependencies installed"

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üèóÔ∏è Build ML inference image
        uses: docker/build-push-action@v5
        with:
          context: ./app/ml-inference
          load: true
          tags: ml-inference:live-demo
          cache-from: type=gha
          push: false

      - name: ‚ò∏Ô∏è Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: üîç Verify cluster
        run: |
          echo "=== Cluster Ready ==="
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Cluster is ready"

      - name: üê≥ Load Docker image into Minikube
        run: |
          echo "Loading ML inference image into Minikube..."
          minikube image load ml-inference:live-demo

          # Tag it as the GHCR image name for deployment
          docker tag ml-inference:live-demo ghcr.io/${{ github.repository_owner }}/ml-inference:latest
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "‚úÖ Image loaded into Minikube"
          minikube image ls | grep ml-inference

      - name: üì¶ Install ArgoCD
        run: |
          echo "Installing ArgoCD..."
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v2.9.3/manifests/install.yaml

          echo "Waiting for ArgoCD to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

          echo "‚úÖ ArgoCD installed"

      - name: üîë Setup ArgoCD
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

          # Install ArgoCD CLI
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/v2.9.3/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

          # Port forward ArgoCD
          kubectl port-forward svc/argocd-server -n argocd 8081:443 > /dev/null 2>&1 &
          sleep 5

          # Login to ArgoCD
          argocd login localhost:8081 --username admin --password $ARGOCD_PASSWORD --insecure

          # Register repository
          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "‚úÖ ArgoCD configured"

      - name: üé® Create dashboard server
        run: |
          cat > /tmp/dashboard_server.py <<- 'EOF'
          from flask import Flask, Response, jsonify
          from flask_cors import CORS
          import subprocess
          import json
          import time
          import threading
          
          app = Flask(__name__)
          CORS(app)
          
          # Global state
          deployment_state = {
              "start_time": time.time(),
              "argocd_apps": [],
              "pods": [],
              "events": [],
              "progress": 0,
              "phase": "Initializing"
          }
          
          def run_command(cmd):
              """Run shell command and return output"""
              try:
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
                  return result.stdout.strip()
              except Exception as e:
                  return f"Error: {str(e)}"
          
          def get_argocd_status():
              """Get ArgoCD application status"""
              try:
                  output = run_command("argocd app list -o json 2>/dev/null || echo '[]'")
                  if output and output != '[]':
                      apps = json.loads(output)
                      return [{
                          "name": app.get("metadata", {}).get("name", "unknown"),
                          "sync": app.get("status", {}).get("sync", {}).get("status", "Unknown"),
                          "health": app.get("status", {}).get("health", {}).get("status", "Unknown"),
                          "revision": app.get("status", {}).get("sync", {}).get("revision", "")[:7]
                      } for app in apps]
              except:
                  pass
              return []
          
          def get_pods_status():
              """Get Kubernetes pods status"""
              try:
                  output = run_command("kubectl get pods -A -o json 2>/dev/null")
                  if output:
                      data = json.loads(output)
                      pods = []
                      for item in data.get("items", []):
                          namespace = item["metadata"]["namespace"]
                          if namespace in ["ml-inference", "monitoring", "argocd"]:
                              name = item["metadata"]["name"]
                              status = item["status"]["phase"]
          
                              # Get container ready status
                              ready = "0/0"
                              if "containerStatuses" in item["status"]:
                                  total = len(item["status"]["containerStatuses"])
                                  ready_count = sum(1 for c in item["status"]["containerStatuses"] if c.get("ready", False))
                                  ready = f"{ready_count}/{total}"
          
                              age = item["metadata"].get("creationTimestamp", "")
          
                              pods.append({
                                  "namespace": namespace,
                                  "name": name,
                                  "status": status,
                                  "ready": ready,
                                  "age": age
                              })
                      return pods
              except:
                  pass
              return []
          
          def get_recent_events():
              """Get recent Kubernetes events"""
              try:
                  output = run_command(
                      "kubectl get events -A --sort-by='.lastTimestamp' -o json 2>/dev/null"
                  )
                  if output:
                      data = json.loads(output)
                      events = []
                      for item in data.get("items", [])[-20:]:  # Last 20 events
                          namespace = item["metadata"]["namespace"]
                          if namespace in ["ml-inference", "monitoring", "argocd"]:
                              events.append({
                                  "time": item.get("lastTimestamp", item.get("eventTime", "")),
                                  "namespace": namespace,
                                  "reason": item.get("reason", ""),
                                  "message": item.get("message", "")[:100]
                              })
                      return events[-10:]  # Return last 10
              except:
                  pass
              return []
          
          def calculate_progress():
              """Calculate deployment progress"""
              apps = deployment_state["argocd_apps"]
              pods = deployment_state["pods"]
          
              if not apps:
                  return 10  # Initial setup
          
              # Check ArgoCD apps
              synced_apps = sum(1 for app in apps if app["sync"] == "Synced")
              healthy_apps = sum(1 for app in apps if app["health"] == "Healthy")
          
              # Check pods
              running_pods = sum(1 for pod in pods if pod["status"] == "Running")
              ready_pods = sum(1 for pod in pods if pod["ready"].split("/")[0] == pod["ready"].split("/")[1])
          
              total_score = 0
              total_score += (synced_apps / max(len(apps), 1)) * 40  # 40% for sync
              total_score += (healthy_apps / max(len(apps), 1)) * 30  # 30% for health
              total_score += (running_pods / max(len(pods), 1)) * 20 if pods else 0  # 20% for running
              total_score += (ready_pods / max(len(pods), 1)) * 10 if pods else 0  # 10% for ready
          
              return min(int(total_score), 100)
          
          def determine_phase():
              """Determine current deployment phase"""
              apps = deployment_state["argocd_apps"]
              pods = deployment_state["pods"]
              progress = deployment_state["progress"]
          
              if progress < 20:
                  return "Initializing ArgoCD"
              elif progress < 50:
                  return "Syncing Applications"
              elif progress < 80:
                  return "Starting Pods"
              elif progress < 100:
                  return "Finalizing Deployment"
              else:
                  return "Deployment Complete"
          
          def update_state():
              """Background thread to update deployment state"""
              while True:
                  try:
                      deployment_state["argocd_apps"] = get_argocd_status()
                      deployment_state["pods"] = get_pods_status()
                      deployment_state["events"] = get_recent_events()
                      deployment_state["progress"] = calculate_progress()
                      deployment_state["phase"] = determine_phase()
                  except Exception as e:
                      print(f"Error updating state: {e}")
                  time.sleep(2)  # Update every 2 seconds
          
          # Start background updater
          threading.Thread(target=update_state, daemon=True).start()
          
          @app.route('/')
          def index():
              """Serve the dashboard HTML"""
              return """<!DOCTYPE html>
          <html><head><title>GitOps Dashboard</title><style>*{margin:0;padding:0}body{font-family:system-ui;background:linear-gradient(135deg,#1e3c72,#2a5298);color:#fff;padding:20px}.container{max-width:1200px;margin:0 auto}.header{text-align:center;margin-bottom:30px;padding:20px;background:rgba(255,255,255,0.1);border-radius:15px}.progress-bar{background:rgba(0,0,0,0.3);border-radius:10px;height:30px;margin:15px 0}.progress-fill{height:100%;background:linear-gradient(90deg,#4CAF50,#8BC34A);transition:width .5s;display:flex;align-items:center;justify-content:center;font-weight:bold}.card{background:rgba(255,255,255,0.1);border-radius:15px;padding:20px;margin-bottom:20px}.grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:20px;margin-bottom:20px}.value{font-size:2em;font-weight:bold}.item{background:rgba(0,0,0,0.2);border-radius:8px;padding:12px;margin:10px 0}.badge{padding:4px 12px;border-radius:12px;font-size:.85em;font-weight:bold;margin-left:10px}.badge-synced,.badge-healthy,.badge-running{background:#4CAF50}.badge-pending,.badge-progressing{background:#FF9800}</style></head><body><div class="container"><div class="header"><h1>Live GitOps Dashboard</h1><p>Real-time deployment monitoring</p></div><div class="card"><h2 id="phase">Initializing...</h2><div class="progress-bar"><div class="progress-fill" id="bar" style="width:0%">0%</div></div><p id="time">Elapsed: 0s</p></div><div class="grid"><div class="card"><h3>ArgoCD Apps</h3><div class="value" id="apps">0</div></div><div class="card"><h3>Pods</h3><div class="value" id="pods">0</div></div><div class="card"><h3>Ready</h3><div class="value" id="ready">0</div></div><div class="card"><h3>Progress</h3><div class="value" id="pct">0%</div></div></div><div class="card"><h2>Applications</h2><div id="appsList">Loading...</div></div><div class="card"><h2>Pods</h2><div id="podsList">Loading...</div></div></div><script>const ev=new EventSource('/api/stream');ev.onmessage=e=>{const d=JSON.parse(e.data);document.getElementById('bar').style.width=d.progress+'%';document.getElementById('bar').textContent=d.progress+'%';document.getElementById('phase').textContent=d.phase;document.getElementById('pct').textContent=d.progress+'%';const m=Math.floor(d.elapsed/60),s=d.elapsed%60;document.getElementById('time').textContent=`Elapsed: ${m}m ${s}s`;document.getElementById('apps').textContent=d.argocd_apps.length;document.getElementById('pods').textContent=d.pods.length;const r=d.pods.filter(p=>p.ready.split('/')[0]==p.ready.split('/')[1]&&p.ready!='0/0').length;document.getElementById('ready').textContent=r;document.getElementById('appsList').innerHTML=d.argocd_apps.length?d.argocd_apps.map(a=>`<div class="item"><strong>${a.name}</strong><span class="badge badge-${a.sync.toLowerCase()}">${a.sync}</span><span class="badge badge-${a.health.toLowerCase()}">${a.health}</span></div>`).join(''):'<p>No apps yet...</p>';document.getElementById('podsList').innerHTML=d.pods.length?d.pods.map(p=>`<div class="item"><strong>${p.name}</strong> (${p.namespace})<span class="badge badge-${p.status.toLowerCase()}">${p.status}</span></div>`).join(''):'<p>No pods yet...</p>'};fetch('/api/status').then(r=>r.json()).then(d=>ev.onmessage({data:JSON.stringify(d)}));</script></body></html>"""
          
          @app.route('/api/status')
          def status():
              """Get current status as JSON"""
              elapsed = int(time.time() - deployment_state["start_time"])
              return jsonify({
                  **deployment_state,
                  "elapsed": elapsed
              })
          
          @app.route('/api/stream')
          def stream():
              """Server-Sent Events stream for real-time updates"""
              def generate():
                  while True:
                      elapsed = int(time.time() - deployment_state["start_time"])
                      data = {
                          **deployment_state,
                          "elapsed": elapsed
                      }
                      yield f"data: {json.dumps(data)}\n\n"
                      time.sleep(2)
          
              return Response(generate(), mimetype='text/event-stream')
          
          @app.route('/api/test/<endpoint>')
          def test_endpoint(endpoint):
              """Test ML inference endpoints"""
              try:
                  if endpoint == 'health':
                      output = run_command("kubectl exec -n ml-inference deploy/ml-inference -- curl -s http://localhost:8000/health")
                  elif endpoint == 'predict':
                      output = run_command('kubectl exec -n ml-inference deploy/ml-inference -- curl -s -X POST http://localhost:8000/predict -H "Content-Type: application/json" -d \'{"text":"This is amazing!"}\'')
                  elif endpoint == 'metrics':
                      output = run_command("kubectl exec -n ml-inference deploy/ml-inference -- curl -s http://localhost:8000/metrics | grep inference_ | head -10")
                  else:
                      return jsonify({"error": "Unknown endpoint"}), 400
          
                  return jsonify({"output": output})
              except Exception as e:
                  return jsonify({"error": str(e)}), 500
          
          if __name__ == '__main__':
              app.run(host='0.0.0.0', port=8080, debug=False)
          EOF

          echo "‚úÖ Dashboard server created"

      - name: üé¨ Start deployment and dashboard
        run: |
          # Start dashboard server in background
          cd /tmp
          python3 dashboard_server.py > /tmp/dashboard.log 2>&1 &
          DASHBOARD_PID=$!
          echo "Dashboard PID: $DASHBOARD_PID"

          sleep 3

          # Test dashboard is running
          curl -f http://localhost:8080/ > /dev/null || {
            echo "Dashboard failed to start!"
            cat /tmp/dashboard.log
            exit 1
          }

          echo "‚úÖ Dashboard server started on port 8080"

      - name: üöÄ Deploy applications via ArgoCD
        run: |
          echo "Creating namespaces..."
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true

          echo "Creating ArgoCD applications..."

          # Create ML Inference app
          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true || echo "App already exists"

          # Create Observability app
          argocd app create observability \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/observability \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace monitoring \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true || echo "App already exists"

          echo "‚úÖ Applications created - watch them sync on the dashboard!"

      - name: üöá Install Cloudflare Tunnel
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          chmod +x cloudflared-linux-amd64
          sudo mv cloudflared-linux-amd64 /usr/local/bin/cloudflared
          cloudflared version

      - name: üåç Start Cloudflare Tunnel
        env:
          TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          echo "================================================"
          echo "üåê Starting Cloudflare Tunnel..."
          echo "================================================"

          # Create tunnel credentials file
          mkdir -p ~/.cloudflared
          echo "$TUNNEL_TOKEN" > ~/.cloudflared/tunnel-token.json

          # Start named tunnel
          cloudflared tunnel --credentials-file ~/.cloudflared/tunnel-token.json run gitops-demo > /tmp/cf-dashboard.log 2>&1 &
          sleep 10

          echo ""
          echo "================================================"
          echo "üé≠ LIVE GITOPS DASHBOARD URL:"
          echo "================================================"
          echo "https://gitops-infra.neevs.io"
          echo "================================================"
          echo ""
          echo "‚è∞ Dashboard will remain open for ${{ inputs.duration }} minutes"
          echo "   Watch your GitOps deployment in real-time!"
          echo ""

          # Keep tunnel alive
          sleep $(( ${{ inputs.duration }} * 60 ))

      - name: üìä Show final status
        if: always()
        run: |
          echo "=== Final Deployment Status ==="
          argocd app list || true
          kubectl get all -n ml-inference || true
          kubectl get all -n monitoring || true

          echo -e "\n=== Dashboard Logs ==="
          tail -50 /tmp/dashboard.log || true

      - name: ‚úÖ Cleanup
        if: always()
        run: |
          pkill -f dashboard_server.py || true
          pkill cloudflared || true
          echo "‚úÖ Cleanup complete"
