name: GitOps Infrastructure Demo

on:
  push:
    branches: [main, claude/gitops-*]
  pull_request:
  workflow_dispatch:
    inputs:
      demo_mode:
        description: 'Demo mode (full or quick)'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - quick

env:
  MINIKUBE_VERSION: v1.32.0
  KUBERNETES_VERSION: v1.28.0
  ARGOCD_VERSION: v2.9.3
  REGISTRY: ghcr.io

jobs:
  # Job 1: Build Docker image (runs first, independently)
  build:
    name: ðŸ—ï¸ Build ML Inference Image
    runs-on: ubuntu-latest
    timeout-minutes: 10

    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“ Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/ml-inference
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=branch
            type=ref,event=pr
            latest

      - name: ðŸ—ï¸ Build and push ML inference image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app/ml-inference
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: âœ… Build complete
        run: |
          echo "âœ… Docker image built and pushed successfully"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  # Job 2: Deploy infrastructure (depends on build)
  deploy:
    name: ðŸš€ Deploy Infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build

    permissions:
      contents: read

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜¸ï¸ Start Minikube cluster
        uses: medyagh/setup-minikube@v0.0.20
        with:
          minikube-version: ${{ env.MINIKUBE_VERSION }}
          kubernetes-version: ${{ env.KUBERNETES_VERSION }}
          cpus: 2
          memory: 4096
          driver: docker
          addons: metrics-server,ingress

      - name: ðŸ” Verify cluster
        run: |
          echo "=== Cluster Info ==="
          kubectl cluster-info
          kubectl version --short

          echo -e "\n=== Nodes ==="
          kubectl get nodes -o wide

          echo -e "\n=== System Pods ==="
          kubectl get pods -n kube-system

      - name: ðŸ“¦ Install ArgoCD
        run: |
          echo "Installing ArgoCD ${{ env.ARGOCD_VERSION }}..."

          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml

          echo "Waiting for ArgoCD pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-repo-server -n argocd --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s

          echo "âœ… ArgoCD installed successfully"

      - name: ðŸ”‘ Get ArgoCD credentials
        id: argocd-creds
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV
          echo "âœ… ArgoCD credentials retrieved"

      - name: ðŸŒ Expose ArgoCD server
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5
          echo "âœ… ArgoCD UI accessible at https://localhost:8080"

      - name: ðŸ› ï¸ Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/
          argocd version --client

      - name: ðŸ” Login to ArgoCD
        run: |
          argocd login localhost:8080 \
            --username admin \
            --password $ARGOCD_PASSWORD \
            --insecure
          echo "âœ… Logged in to ArgoCD"

      - name: ðŸ“ Create namespaces
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true
          echo "âœ… Namespaces created"

      - name: ðŸš€ Deploy ML Inference via ArgoCD
        run: |
          echo "Creating ML Inference application..."

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true

          echo "âœ… ML Inference application created"

      - name: ðŸ“Š Deploy Observability Stack via ArgoCD
        run: |
          echo "Creating Observability application..."

          argocd app create observability \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/observability \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace monitoring \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true

          echo "âœ… Observability application created"

      - name: â³ Wait for applications to sync
        run: |
          echo "Waiting for applications to sync..."
          argocd app wait ml-inference --timeout 300 --health || true
          argocd app wait observability --timeout 300 --health || true
          echo "âœ… Applications synced"

      - name: ðŸ” Verify ArgoCD applications
        run: |
          echo "=== ArgoCD Applications ==="
          argocd app list

          echo -e "\n=== ML Inference App Details ==="
          argocd app get ml-inference

          echo -e "\n=== Observability App Details ==="
          argocd app get observability

      - name: ðŸ” Verify Kubernetes resources
        run: |
          echo "=== All Namespaces ==="
          kubectl get namespaces

          echo -e "\n=== ML Inference Namespace ==="
          kubectl get all -n ml-inference

          echo -e "\n=== Monitoring Namespace ==="
          kubectl get all -n monitoring

          echo -e "\n=== ML Inference Pods ==="
          kubectl get pods -n ml-inference -o wide

      - name: ðŸ’¾ Save cluster state
        run: |
          mkdir -p /tmp/cluster-state

          # Save kubeconfig
          kubectl config view --raw > /tmp/cluster-state/kubeconfig

          # Save ArgoCD password
          echo $ARGOCD_PASSWORD > /tmp/cluster-state/argocd-password

          # Save cluster info
          kubectl cluster-info > /tmp/cluster-state/cluster-info.txt
          kubectl get all --all-namespaces > /tmp/cluster-state/all-resources.txt

      - name: ðŸ“¤ Upload cluster state
        uses: actions/upload-artifact@v4
        with:
          name: cluster-state
          path: /tmp/cluster-state/
          retention-days: 1

      - name: âœ… Deployment complete
        run: |
          echo "âœ… Infrastructure deployed successfully"
          echo "   â€¢ Minikube cluster running"
          echo "   â€¢ ArgoCD installed and configured"
          echo "   â€¢ ML Inference service deployed"
          echo "   â€¢ Observability stack deployed"

  # Job 3a: Run tests (depends on deploy, runs in parallel with demo)
  test:
    name: ðŸ§ª Run Health Checks & Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy

    permissions:
      contents: read

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download cluster state
        uses: actions/download-artifact@v4
        with:
          name: cluster-state
          path: /tmp/cluster-state/

      - name: â˜¸ï¸ Start Minikube cluster
        uses: medyagh/setup-minikube@v0.0.20
        with:
          minikube-version: ${{ env.MINIKUBE_VERSION }}
          kubernetes-version: ${{ env.KUBERNETES_VERSION }}
          cpus: 2
          memory: 4096
          driver: docker
          addons: metrics-server,ingress

      - name: ðŸ”„ Restore cluster state
        run: |
          # Wait for cluster to be ready
          kubectl wait --for=condition=ready node --all --timeout=300s

          echo "Note: Running tests on fresh cluster (cluster state is reference only)"

      - name: ðŸ“¦ Re-install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: ðŸ”‘ Get ArgoCD credentials
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

      - name: ðŸ› ï¸ Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

      - name: ðŸ” Login to ArgoCD
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5
          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

      - name: ðŸš€ Deploy applications
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune

          argocd app wait ml-inference --timeout 300 --health || true

      - name: âœ… Run health checks
        run: |
          echo "Waiting for ML inference pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=ml-inference -n ml-inference --timeout=180s

          echo -e "\n=== Testing ML Inference Service ==="

          # Port forward the service
          kubectl port-forward -n ml-inference svc/ml-inference 8000:80 > /dev/null 2>&1 &
          PF_PID=$!
          sleep 5

          # Health check
          echo "Testing /health endpoint..."
          curl -f http://localhost:8000/health | jq .

          # Readiness check
          echo -e "\nTesting /ready endpoint..."
          curl -f http://localhost:8000/ready | jq .

          # Inference test
          echo -e "\nTesting /predict endpoint..."
          curl -f -X POST http://localhost:8000/predict \
            -H "Content-Type: application/json" \
            -d '{"text": "This GitOps demo is amazing!"}' | jq .

          # Batch inference test
          echo -e "\nTesting /predict/batch endpoint..."
          curl -f -X POST http://localhost:8000/predict/batch \
            -H "Content-Type: application/json" \
            -d '{"texts": ["Great work!", "This is terrible", "Just okay"]}' | jq .

          # Metrics check
          echo -e "\nTesting /metrics endpoint..."
          curl -f http://localhost:8000/metrics | grep -E "^inference_" | head -10

          kill $PF_PID || true

          echo -e "\nâœ… All health checks passed!"

      - name: ðŸ“Š Collect test metrics
        if: always()
        run: |
          mkdir -p /tmp/test-results

          # Get pod status
          kubectl get pods -n ml-inference -o yaml > /tmp/test-results/pod-status.yaml

          # Get pod logs
          kubectl logs -n ml-inference -l app=ml-inference --tail=100 > /tmp/test-results/ml-inference.log || true

          # Get events
          kubectl get events -n ml-inference --sort-by='.lastTimestamp' > /tmp/test-results/events.txt

      - name: ðŸ“¤ Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: /tmp/test-results/
          retention-days: 30

      - name: âœ… Tests complete
        run: |
          echo "âœ… All tests passed successfully!"

  # Job 3b: GitOps self-healing demo (depends on deploy, runs in parallel with test)
  demo:
    name: ðŸŽ­ GitOps Self-Healing Demo
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: deploy
    if: github.event.inputs.demo_mode == 'full' || github.event_name == 'workflow_dispatch'

    permissions:
      contents: read

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â˜¸ï¸ Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: ${{ env.MINIKUBE_VERSION }}
          kubernetes-version: ${{ env.KUBERNETES_VERSION }}
          cpus: 2
          memory: 4096
          driver: docker

      - name: ðŸ“¦ Install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: ðŸ”‘ Setup ArgoCD
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"

          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5

          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

      - name: ðŸš€ Deploy ML Inference
        run: |
          kubectl create namespace ml-inference

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune

          argocd app wait ml-inference --timeout 300 --health || true

      - name: ðŸ”„ Demonstrate GitOps self-healing
        run: |
          echo "=== Demonstrating GitOps Self-Healing ==="

          echo -e "\n1. Current state (from Git):"
          ORIGINAL_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $ORIGINAL_REPLICAS"

          echo -e "\n2. Manually scaling deployment (simulating drift)..."
          kubectl scale deployment ml-inference -n ml-inference --replicas=5
          sleep 3

          echo -e "\n3. Deployment now has:"
          DRIFTED_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $DRIFTED_REPLICAS"

          echo -e "\n4. ArgoCD detects drift..."
          argocd app get ml-inference | grep -A 5 "Sync Status"

          echo -e "\n5. Waiting for ArgoCD to self-heal (sync back to Git state)..."
          sleep 30

          echo -e "\n6. After self-healing:"
          HEALED_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $HEALED_REPLICAS"

          if [ "$HEALED_REPLICAS" -eq "$ORIGINAL_REPLICAS" ]; then
            echo -e "\nâœ… GitOps self-healing successful!"
          else
            echo -e "\nâš ï¸ Self-healing still in progress..."
          fi

      - name: ðŸ“¸ Capture demo artifacts
        if: always()
        run: |
          mkdir -p /tmp/demo-artifacts

          argocd app get ml-inference -o json > /tmp/demo-artifacts/ml-inference.json || true
          argocd app history ml-inference > /tmp/demo-artifacts/ml-inference-history.txt || true
          kubectl get events -n ml-inference --sort-by='.lastTimestamp' > /tmp/demo-artifacts/events.txt || true
          kubectl describe deployment ml-inference -n ml-inference > /tmp/demo-artifacts/deployment-describe.txt || true

      - name: ðŸ“¤ Upload demo artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: demo-artifacts
          path: /tmp/demo-artifacts/
          retention-days: 30

      - name: âœ… Demo complete
        run: |
          echo "âœ… GitOps self-healing demonstration complete!"

  # Job 4: Generate report (depends on test and demo, always runs)
  report:
    name: ðŸ“Š Generate Final Report
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [build, deploy, test]
    if: always()

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: /tmp/artifacts/

      - name: ðŸ“Š Generate demo report
        run: |
          mkdir -p /tmp/final-report

          cat > /tmp/final-report/DEMO-REPORT.md << 'EOFF'
          # GitOps Infrastructure Demo Report

          ## ðŸŽ¯ Demonstration Summary

          This workflow successfully demonstrated:

          - âœ… **Docker Build & Push** - ML inference image built and pushed to GHCR
          - âœ… **ArgoCD GitOps deployment** - Declarative, Git-driven infrastructure
          - âœ… **Kubernetes orchestration** - Multi-service deployment on Minikube
          - âœ… **ML Model Serving** - FastAPI inference service with sentiment analysis
          - âœ… **Observability Stack** - Prometheus and Grafana for monitoring
          - âœ… **Health checks** - All services passed liveness and readiness probes
          - âœ… **Self-healing** - ArgoCD automatic drift detection and correction

          ## ðŸ“ˆ Workflow Results

          EOFF

          # Add build status
          echo "### Build Status" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Build job: ${{ needs.build.result }}" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Deploy job: ${{ needs.deploy.result }}" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Test job: ${{ needs.test.result }}" >> /tmp/final-report/DEMO-REPORT.md

          # Add timing information
          cat >> /tmp/final-report/DEMO-REPORT.md << 'EOFF'

          ## ðŸš€ Key Takeaways

          1. **Parallelized Workflow**: Build, test, and demo jobs run efficiently
          2. **GitOps in Action**: All deployments managed through Git with ArgoCD
          3. **Production Patterns**: Health checks, resource limits, auto-scaling ready
          4. **Observable**: Prometheus metrics, application logs, K8s events
          5. **Self-healing**: Demonstrated automatic drift correction
          6. **Zero Cost**: Entire demo runs in GitHub Actions (no cloud account needed)

          ## ðŸ“Š Architecture

          ```
          GitHub Actions Workflow
          â”‚
          â”œâ”€â”€ Job 1: Build (ðŸ—ï¸)
          â”‚   â””â”€â”€ Docker image â†’ GHCR
          â”‚
          â”œâ”€â”€ Job 2: Deploy (ðŸš€) [depends on Build]
          â”‚   â”œâ”€â”€ Minikube cluster
          â”‚   â”œâ”€â”€ ArgoCD installation
          â”‚   â””â”€â”€ Application deployment
          â”‚
          â”œâ”€â”€ Job 3a: Test (ðŸ§ª) [parallel, depends on Deploy]
          â”‚   â””â”€â”€ Health checks & API tests
          â”‚
          â”œâ”€â”€ Job 3b: Demo (ðŸŽ­) [parallel, depends on Deploy]
          â”‚   â””â”€â”€ GitOps self-healing demo
          â”‚
          â””â”€â”€ Job 4: Report (ðŸ“Š) [depends on all]
              â””â”€â”€ Aggregate results & artifacts
          ```

          ## ðŸ’¡ Technologies Demonstrated

          - **GitOps**: ArgoCD for declarative deployments
          - **Kubernetes**: Container orchestration
          - **CI/CD**: GitHub Actions with job parallelization
          - **ML Ops**: FastAPI model serving
          - **Observability**: Prometheus + Grafana
          - **Python**: FastAPI application
          - **Docker**: Container packaging & GHCR

          ---

          **Duration**: ~10-15 minutes (with parallelization)
          **Cost**: $0 (GitHub Actions free tier)
          **Reproducible**: âœ… Anyone can run this workflow
          EOFF

          cat /tmp/final-report/DEMO-REPORT.md

      - name: ðŸ“¤ Upload final report
        uses: actions/upload-artifact@v4
        with:
          name: final-demo-report
          path: /tmp/final-report/
          retention-days: 30

      - name: ðŸ“ Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('/tmp/final-report/DEMO-REPORT.md', 'utf8');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## GitOps Demo Results\n\n${report}\n\n[View full artifacts](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
            });

      - name: âœ… Report complete
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                                            â•‘"
          echo "â•‘   âœ… GitOps Infrastructure Demo Complete   â•‘"
          echo "â•‘                                            â•‘"
          echo "â•‘   Workflow Summary:                        â•‘"
          echo "â•‘   â€¢ Build: ${{ needs.build.result }}"
          echo "â•‘   â€¢ Deploy: ${{ needs.deploy.result }}"
          echo "â•‘   â€¢ Test: ${{ needs.test.result }}"
          echo "â•‘                                            â•‘"
          echo "â•‘   Download artifacts for full details      â•‘"
          echo "â•‘                                            â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
