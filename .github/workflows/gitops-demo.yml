name: GitOps Infrastructure Demo

on:
  schedule:
    # Run daily at 9:00 AM UTC (adjust timezone as needed)
    - cron: '0 9 * * *'
  workflow_dispatch:
    inputs:
      demo_mode:
        description: 'Demo mode (full or quick)'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - quick

# Cancel in-progress runs when a new one starts
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  ARGOCD_VERSION: v2.9.3
  REGISTRY: ghcr.io

jobs:
  # Job 1: Build Docker image (runs first, independently)
  build:
    name: üèóÔ∏è Build ML Inference Image
    runs-on: ubuntu-22.04
    timeout-minutes: 10

    permissions:
      contents: read
      packages: write

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üìù Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/ml-inference
          tags: |
            type=sha,prefix={{branch}}-
            type=ref,event=branch
            type=ref,event=pr
            latest

      - name: üèóÔ∏è Build and push ML inference image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app/ml-inference
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ‚úÖ Build complete
        run: |
          echo "‚úÖ Docker image built and pushed successfully"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  # Job 2: Deploy infrastructure (depends on build)
  deploy:
    name: üöÄ Deploy Infrastructure
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    needs: build

    permissions:
      contents: read
      packages: read

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚ò∏Ô∏è Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: üîç Verify cluster
        run: |
          echo "=== Cluster Info ==="
          kubectl cluster-info
          kubectl version

          echo -e "\n=== Nodes ==="
          kubectl get nodes -o wide

          echo -e "\n=== System Pods ==="
          kubectl get pods -n kube-system

      - name: üì¶ Install ArgoCD
        run: |
          echo "Installing ArgoCD ${{ env.ARGOCD_VERSION }}..."

          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml

          echo "Waiting for ArgoCD pods to be ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-repo-server -n argocd --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=300s

          echo "‚úÖ ArgoCD installed successfully"

      - name: üîë Get ArgoCD credentials
        id: argocd-creds
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV
          echo "‚úÖ ArgoCD credentials retrieved"

      - name: üåê Expose ArgoCD server
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5
          echo "‚úÖ ArgoCD UI accessible at https://localhost:8080"

      - name: üõ†Ô∏è Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/
          argocd version --client

      - name: üîê Login to ArgoCD
        run: |
          argocd login localhost:8080 \
            --username admin \
            --password $ARGOCD_PASSWORD \
            --insecure
          echo "‚úÖ Logged in to ArgoCD"

      - name: üì¶ Register Git repository with ArgoCD
        run: |
          echo "Registering repository with ArgoCD..."

          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "‚úÖ Repository registered with ArgoCD"

      - name: üîê Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üê≥ Setup Docker image in Minikube
        run: |
          echo "Pulling Docker image from GHCR..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Loading image into Minikube..."
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Verifying image in Minikube..."
          minikube image ls | grep ml-inference

          echo "‚úÖ Docker image loaded into Minikube"

      - name: üìù Create namespaces
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true
          echo "‚úÖ Namespaces created"

      - name: üöÄ Deploy ML Inference via ArgoCD
        run: |
          echo "Creating ML Inference application..."

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true

          echo "‚úÖ ML Inference application created"

      - name: üìä Deploy Observability Stack via ArgoCD
        run: |
          echo "Creating Observability application..."

          argocd app create observability \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/observability \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace monitoring \
            --sync-policy automated \
            --self-heal \
            --auto-prune \
            --sync-option CreateNamespace=true

          echo "‚úÖ Observability application created"

      - name: ‚è≥ Wait for applications to sync
        run: |
          echo "Waiting for applications to sync..."

          # Give ArgoCD a moment to detect the apps
          sleep 5

          # Manually trigger sync to ensure it starts
          echo "Triggering manual sync for ml-inference..."
          argocd app sync ml-inference --prune || true

          echo "Triggering manual sync for observability..."
          argocd app sync observability --prune || true

          # Wait for health with timeout
          echo "Waiting for ml-inference to be healthy..."
          argocd app wait ml-inference --timeout 180 --health || {
            echo "‚ö†Ô∏è ml-inference did not become healthy in time"
            argocd app get ml-inference
          }

          echo "Waiting for observability to be healthy..."
          argocd app wait observability --timeout 180 --health || {
            echo "‚ö†Ô∏è observability did not become healthy in time"
            argocd app get observability
          }

          echo "‚úÖ Applications sync attempted"

      - name: üîç Verify ArgoCD applications
        run: |
          echo "=== ArgoCD Applications ==="
          argocd app list

          echo -e "\n=== ML Inference App Details ==="
          argocd app get ml-inference

          echo -e "\n=== Observability App Details ==="
          argocd app get observability

      - name: üîç Verify Kubernetes resources
        run: |
          echo "=== All Namespaces ==="
          kubectl get namespaces

          echo -e "\n=== ML Inference Namespace ==="
          kubectl get all -n ml-inference

          echo -e "\n=== Monitoring Namespace ==="
          kubectl get all -n monitoring

          echo -e "\n=== ML Inference Pods ==="
          kubectl get pods -n ml-inference -o wide

      - name: üíæ Save cluster state
        run: |
          mkdir -p /tmp/cluster-state

          # Save kubeconfig
          kubectl config view --raw > /tmp/cluster-state/kubeconfig

          # Save ArgoCD password
          echo $ARGOCD_PASSWORD > /tmp/cluster-state/argocd-password

          # Save cluster info
          kubectl cluster-info > /tmp/cluster-state/cluster-info.txt
          kubectl get all --all-namespaces > /tmp/cluster-state/all-resources.txt

      - name: üì§ Upload cluster state
        uses: actions/upload-artifact@v4
        with:
          name: cluster-state
          path: /tmp/cluster-state/
          retention-days: 1

      - name: ‚úÖ Deployment complete
        run: |
          echo "‚úÖ Infrastructure deployed successfully"
          echo "   ‚Ä¢ Minikube cluster running"
          echo "   ‚Ä¢ ArgoCD installed and configured"
          echo "   ‚Ä¢ ML Inference service deployed"
          echo "   ‚Ä¢ Observability stack deployed"

  # Job 3a: Run tests (depends on deploy, runs in parallel with demo)
  test:
    name: üß™ Run Health Checks & Tests
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: deploy

    permissions:
      contents: read
      packages: read

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì• Download cluster state
        uses: actions/download-artifact@v4
        with:
          name: cluster-state
          path: /tmp/cluster-state/

      - name: ‚ò∏Ô∏è Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: üîÑ Restore cluster state
        run: |
          # Wait for cluster to be ready
          kubectl wait --for=condition=ready node --all --timeout=300s

          echo "Note: Running tests on fresh cluster (cluster state is reference only)"

      - name: üì¶ Re-install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: üîë Get ArgoCD credentials
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

      - name: üõ†Ô∏è Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

      - name: üîê Login to ArgoCD
        run: |
          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5
          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

      - name: üì¶ Register Git repository with ArgoCD
        run: |
          echo "Registering repository with ArgoCD..."

          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "‚úÖ Repository registered with ArgoCD"

      - name: üîê Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üê≥ Setup Docker image in Minikube
        run: |
          echo "Pulling Docker image from GHCR..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Loading image into Minikube..."
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Verifying image in Minikube..."
          minikube image ls | grep ml-inference

          echo "‚úÖ Docker image loaded into Minikube"

      - name: üöÄ Deploy applications
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune

          argocd app wait ml-inference --timeout 300 --health || true

      - name: ‚úÖ Run health checks
        run: |
          echo "Waiting for ML inference pods to be ready..."
          kubectl wait --for=condition=ready pod -l app=ml-inference -n ml-inference --timeout=180s

          echo -e "\n=== Testing ML Inference Service ==="

          # Port forward the service
          kubectl port-forward -n ml-inference svc/ml-inference 8000:80 > /dev/null 2>&1 &
          PF_PID=$!
          sleep 5

          # Health check
          echo "Testing /health endpoint..."
          curl -f http://localhost:8000/health | jq .

          # Readiness check
          echo -e "\nTesting /ready endpoint..."
          curl -f http://localhost:8000/ready | jq .

          # Inference test
          echo -e "\nTesting /predict endpoint..."
          curl -f -X POST http://localhost:8000/predict \
            -H "Content-Type: application/json" \
            -d '{"text": "This GitOps demo is amazing!"}' | jq .

          # Batch inference test
          echo -e "\nTesting /predict/batch endpoint..."
          curl -f -X POST http://localhost:8000/predict/batch \
            -H "Content-Type: application/json" \
            -d '{"texts": ["Great work!", "This is terrible", "Just okay"]}' | jq .

          # Metrics check
          echo -e "\nTesting /metrics endpoint..."
          curl -f http://localhost:8000/metrics | grep -E "^inference_" | head -10

          kill $PF_PID || true

          echo -e "\n‚úÖ All health checks passed!"

      - name: üìä Collect test metrics
        if: always()
        run: |
          mkdir -p /tmp/test-results

          # Get pod status
          kubectl get pods -n ml-inference -o yaml > /tmp/test-results/pod-status.yaml

          # Get pod logs
          kubectl logs -n ml-inference -l app=ml-inference --tail=100 > /tmp/test-results/ml-inference.log || true

          # Get events
          kubectl get events -n ml-inference --sort-by='.lastTimestamp' > /tmp/test-results/events.txt

      - name: üì§ Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: /tmp/test-results/
          retention-days: 30

      - name: ‚úÖ Tests complete
        run: |
          echo "‚úÖ All tests passed successfully!"

  # Job 3b: GitOps self-healing demo (depends on deploy, runs in parallel with test)
  demo:
    name: üé≠ GitOps Self-Healing Demo
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    needs: deploy
    if: github.event.inputs.demo_mode == 'full' || github.event_name == 'workflow_dispatch'

    permissions:
      contents: read
      packages: read

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚ò∏Ô∏è Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096

      - name: üì¶ Install ArgoCD
        run: |
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: üîë Setup ArgoCD
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"

          kubectl port-forward svc/argocd-server -n argocd 8080:443 > /dev/null 2>&1 &
          sleep 5

          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

          argocd login localhost:8080 --username admin --password $ARGOCD_PASSWORD --insecure

      - name: üì¶ Register Git repository with ArgoCD
        run: |
          echo "Registering repository with ArgoCD..."

          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "‚úÖ Repository registered with ArgoCD"

      - name: üîê Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üê≥ Setup Docker image in Minikube
        run: |
          echo "Pulling Docker image from GHCR..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Loading image into Minikube..."
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest

          echo "Verifying image in Minikube..."
          minikube image ls | grep ml-inference

          echo "‚úÖ Docker image loaded into Minikube"

      - name: üöÄ Deploy ML Inference
        run: |
          kubectl create namespace ml-inference

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated \
            --self-heal \
            --auto-prune

          argocd app wait ml-inference --timeout 300 --health || true

      - name: üîÑ Demonstrate GitOps self-healing
        run: |
          echo "=== Demonstrating GitOps Self-Healing ==="

          echo -e "\n1. Current state (from Git):"
          ORIGINAL_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $ORIGINAL_REPLICAS"

          echo -e "\n2. Manually scaling deployment (simulating drift)..."
          kubectl scale deployment ml-inference -n ml-inference --replicas=5
          sleep 3

          echo -e "\n3. Deployment now has:"
          DRIFTED_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $DRIFTED_REPLICAS"

          echo -e "\n4. ArgoCD detects drift..."
          argocd app get ml-inference | grep -A 5 "Sync Status"

          echo -e "\n5. Waiting for ArgoCD to self-heal (sync back to Git state)..."
          sleep 30

          echo -e "\n6. After self-healing:"
          HEALED_REPLICAS=$(kubectl get deployment ml-inference -n ml-inference -o jsonpath='{.spec.replicas}')
          echo "   Replicas: $HEALED_REPLICAS"

          if [ "$HEALED_REPLICAS" -eq "$ORIGINAL_REPLICAS" ]; then
            echo -e "\n‚úÖ GitOps self-healing successful!"
          else
            echo -e "\n‚ö†Ô∏è Self-healing still in progress..."
          fi

      - name: üì∏ Capture demo artifacts
        if: always()
        run: |
          mkdir -p /tmp/demo-artifacts

          argocd app get ml-inference -o json > /tmp/demo-artifacts/ml-inference.json || true
          argocd app history ml-inference > /tmp/demo-artifacts/ml-inference-history.txt || true
          kubectl get events -n ml-inference --sort-by='.lastTimestamp' > /tmp/demo-artifacts/events.txt || true
          kubectl describe deployment ml-inference -n ml-inference > /tmp/demo-artifacts/deployment-describe.txt || true

      - name: üì§ Upload demo artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: demo-artifacts
          path: /tmp/demo-artifacts/
          retention-days: 30

      - name: ‚úÖ Demo complete
        run: |
          echo "‚úÖ GitOps self-healing demonstration complete!"

  # Job 4: Live Dashboard (runs in parallel, provides public URL)
  dashboard:
    name: üé≠ Live Dashboard
    runs-on: ubuntu-22.04
    timeout-minutes: 25
    needs: build

    permissions:
      contents: read
      packages: read

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          pip install flask flask-cors
          echo "‚úÖ Python dependencies installed"

      - name: üîê Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ‚ò∏Ô∏è Start Minikube cluster
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          cpus: 2
          memory: 4096
          addons: metrics-server,ingress

      - name: üîç Verify cluster
        run: |
          echo "=== Cluster Ready ==="
          kubectl cluster-info
          kubectl get nodes
          echo "‚úÖ Cluster is ready"

      - name: üê≥ Load Docker image
        run: |
          echo "Pulling and loading ML inference image..."
          docker pull ghcr.io/${{ github.repository_owner }}/ml-inference:latest
          minikube image load ghcr.io/${{ github.repository_owner }}/ml-inference:latest
          echo "‚úÖ Image loaded into Minikube"

      - name: üì¶ Install ArgoCD
        run: |
          echo "Installing ArgoCD..."
          kubectl create namespace argocd
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s
          echo "‚úÖ ArgoCD installed"

      - name: üîë Setup ArgoCD
        run: |
          sleep 10
          ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
          echo "::add-mask::$ARGOCD_PASSWORD"
          echo "ARGOCD_PASSWORD=$ARGOCD_PASSWORD" >> $GITHUB_ENV

          # Install ArgoCD CLI
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

          # Port forward ArgoCD
          kubectl port-forward svc/argocd-server -n argocd 8081:443 > /dev/null 2>&1 &
          sleep 5

          # Login and register repository
          argocd login localhost:8081 --username admin --password $ARGOCD_PASSWORD --insecure
          argocd repo add https://github.com/${{ github.repository }}.git \
            --username ${{ github.actor }} \
            --password ${{ secrets.GITHUB_TOKEN }} \
            --insecure-skip-server-verification \
            --upsert

          echo "‚úÖ ArgoCD configured"

      - name: üé® Create dashboard server
        run: |
          cat > /tmp/dashboard_server.py <<- 'PYEOF'
          from flask import Flask, Response, jsonify
          from flask_cors import CORS
          import subprocess
          import json
          import time
          import threading
          
          app = Flask(__name__)
          CORS(app)
          
          deployment_state = {
              "start_time": time.time(),
              "argocd_apps": [],
              "pods": [],
              "events": [],
              "progress": 0,
              "phase": "Initializing"
          }
          
          def run_command(cmd):
              try:
                  result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
                  return result.stdout.strip()
              except:
                  return ""
          
          def get_argocd_status():
              try:
                  output = run_command("argocd app list -o json 2>/dev/null || echo '[]'")
                  if output and output != '[]':
            apps = json.loads(output)
            return [{"name": app.get("metadata", {}).get("name", "unknown"),
                     "sync": app.get("status", {}).get("sync", {}).get("status", "Unknown"),
                     "health": app.get("status", {}).get("health", {}).get("status", "Unknown")}
                    for app in apps]
              except:
                  pass
              return []
          
          def get_pods_status():
              try:
                  output = run_command("kubectl get pods -A -o json 2>/dev/null")
                  if output:
            data = json.loads(output)
            pods = []
            for item in data.get("items", []):
                ns = item["metadata"]["namespace"]
                if ns in ["ml-inference", "monitoring", "argocd"]:
                    ready = "0/0"
                    if "containerStatuses" in item["status"]:
                        total = len(item["status"]["containerStatuses"])
                        ready_count = sum(1 for c in item["status"]["containerStatuses"] if c.get("ready"))
                        ready = f"{ready_count}/{total}"
                    pods.append({"namespace": ns, "name": item["metadata"]["name"],
                                "status": item["status"]["phase"], "ready": ready})
            return pods
              except:
                  pass
              return []
          
          def calculate_progress():
              apps = deployment_state["argocd_apps"]
              pods = deployment_state["pods"]
              if not apps:
                  return 10
              synced = sum(1 for app in apps if app["sync"] == "Synced")
              healthy = sum(1 for app in apps if app["health"] == "Healthy")
              running = sum(1 for pod in pods if pod["status"] == "Running")
              score = (synced / max(len(apps), 1)) * 50 + (healthy / max(len(apps), 1)) * 30
              score += (running / max(len(pods), 1)) * 20 if pods else 0
              return min(int(score), 100)
          
          def update_state():
              while True:
                  try:
            deployment_state["argocd_apps"] = get_argocd_status()
            deployment_state["pods"] = get_pods_status()
            deployment_state["progress"] = calculate_progress()
            p = deployment_state["progress"]
            if p < 30:
                deployment_state["phase"] = "Initializing"
            elif p < 70:
                deployment_state["phase"] = "Syncing Applications"
            elif p < 100:
                deployment_state["phase"] = "Starting Services"
            else:
                deployment_state["phase"] = "Deployment Complete"
                  except:
            pass
                  time.sleep(3)
          
          threading.Thread(target=update_state, daemon=True).start()
          
          @app.route('/')
          def index():
              html = '''<!DOCTYPE html>
          <html><head><meta charset="UTF-8"><title>Live GitOps Dashboard</title>
          <style>
          * { margin: 0; padding: 0; box-sizing: border-box; }
          body { font-family: system-ui, -apple-system, sans-serif; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
                 color: white; padding: 20px; min-height: 100vh; }
          .container { max-width: 1200px; margin: 0 auto; }
          .header { text-align: center; margin-bottom: 30px; padding: 20px; background: rgba(255,255,255,0.1);
          border-radius: 15px; backdrop-filter: blur(10px); }
          .header h1 { font-size: 2.5em; margin-bottom: 10px; }
          .progress-section { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 25px; margin-bottom: 20px; }
          .progress-bar { background: rgba(0,0,0,0.3); border-radius: 10px; height: 30px; overflow: hidden; margin: 15px 0; }
          .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A);
                 transition: width 0.5s ease; display: flex; align-items: center;
                 justify-content: center; font-weight: bold; }
          .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
          .card { background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; }
          .card h3 { font-size: 1em; opacity: 0.9; margin-bottom: 10px; }
          .card .value { font-size: 2em; font-weight: bold; }
          .item { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 12px; margin-bottom: 10px; }
          .badge { padding: 4px 12px; border-radius: 12px; font-size: 0.85em; font-weight: bold; display: inline-block; margin-left: 10px; }
          .badge-synced, .badge-healthy, .badge-running { background: #4CAF50; }
          .badge-pending, .badge-progressing { background: #FF9800; }
          .live-indicator { display: inline-block; width: 10px; height: 10px; background: #f44336;
                  border-radius: 50%; animation: pulse 2s infinite; margin-right: 8px; }
          @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
          </style>
          </head>
          <body>
          <div class="container">
            <div class="header">
              <h1>üé≠ Live GitOps Dashboard</h1>
              <p><span class="live-indicator"></span>Real-time deployment monitoring</p>
            </div>
            <div class="progress-section">
              <h2 id="phaseText">Initializing...</h2>
              <div class="progress-bar"><div class="progress-fill" id="progressBar" style="width:0%">0%</div></div>
              <p id="elapsed">Elapsed: 0s</p>
            </div>
            <div class="grid">
              <div class="card"><h3>üì¶ ArgoCD Apps</h3><div class="value" id="appCount">0</div></div>
              <div class="card"><h3>‚ò∏Ô∏è Pods</h3><div class="value" id="podCount">0</div></div>
              <div class="card"><h3>‚úÖ Running</h3><div class="value" id="runningPods">0</div></div>
              <div class="card"><h3>üìà Progress</h3><div class="value" id="progressPercent">0%</div></div>
            </div>
            <div class="progress-section">
              <h2>üîÑ ArgoCD Applications</h2><div id="appsList">Loading...</div>
            </div>
            <div class="progress-section">
              <h2>‚ò∏Ô∏è Kubernetes Pods</h2><div id="podsList">Loading...</div>
            </div>
          </div>
          <script>
          const eventSource = new EventSource('/api/stream');
          eventSource.onmessage = function(e) {
            const data = JSON.parse(e.data);
            document.getElementById('progressBar').style.width = data.progress + '%';
            document.getElementById('progressBar').textContent = data.progress + '%';
            document.getElementById('phaseText').textContent = data.phase;
            document.getElementById('progressPercent').textContent = data.progress + '%';
            const mins = Math.floor(data.elapsed / 60);
            const secs = data.elapsed % 60;
            document.getElementById('elapsed').textContent = `Elapsed: ${mins}m ${secs}s`;
            document.getElementById('appCount').textContent = data.argocd_apps.length;
            document.getElementById('podCount').textContent = data.pods.length;
            const running = data.pods.filter(p => p.status === 'Running').length;
            document.getElementById('runningPods').textContent = running;
            document.getElementById('appsList').innerHTML = data.argocd_apps.length ? data.argocd_apps.map(app =>
              `<div class="item"><strong>${app.name}</strong>
               <span class="badge badge-${app.sync.toLowerCase()}">${app.sync}</span>
               <span class="badge badge-${app.health.toLowerCase()}">${app.health}</span></div>`).join('') :
              '<p>No applications yet...</p>';
            document.getElementById('podsList').innerHTML = data.pods.length ? data.pods.map(pod =>
              `<div class="item"><strong>${pod.name}</strong> (${pod.namespace})
               <span class="badge badge-${pod.status.toLowerCase()}">${pod.status}</span>
               <small style="opacity:0.7; margin-left:10px;">${pod.ready} ready</small></div>`).join('') :
              '<p>No pods yet...</p>';
          };
          </script>
          </body></html>'''
              return html
          
          @app.route('/api/stream')
          def stream():
              def generate():
                  while True:
            elapsed = int(time.time() - deployment_state["start_time"])
            data = {**deployment_state, "elapsed": elapsed, "events": [], "start_time": None}
            yield f"data: {json.dumps(data)}\n\n"
            time.sleep(3)
              return Response(generate(), mimetype='text/event-stream')
          
          if __name__ == '__main__':
              app.run(host='0.0.0.0', port=8080, debug=False)
          PYEOF
          echo "‚úÖ Dashboard server created"

      - name: üé¨ Start dashboard server
        run: |
          python3 /tmp/dashboard_server.py > /tmp/dashboard.log 2>&1 &
          sleep 3
          curl -f http://localhost:8080/ > /dev/null && echo "‚úÖ Dashboard running on port 8080"

      - name: üöÄ Deploy applications
        run: |
          kubectl create namespace ml-inference || true
          kubectl create namespace monitoring || true

          argocd app create ml-inference \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/inference-service \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace ml-inference \
            --sync-policy automated --self-heal --auto-prune || echo "App exists"

          argocd app create observability \
            --repo https://github.com/${{ github.repository }}.git \
            --path k8s/observability \
            --revision ${{ github.ref_name }} \
            --dest-server https://kubernetes.default.svc \
            --dest-namespace monitoring \
            --sync-policy automated --self-heal --auto-prune || echo "App exists"

          echo "‚úÖ Applications created"

      - name: üöá Install Cloudflare Tunnel
        run: |
          wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          chmod +x cloudflared-linux-amd64
          sudo mv cloudflared-linux-amd64 /usr/local/bin/cloudflared
          cloudflared version

      - name: üåç Start Cloudflare Tunnel
        env:
          TUNNEL_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          echo "================================================"
          echo "üé≠ STARTING LIVE GITOPS DASHBOARD"
          echo "================================================"

          # Create tunnel credentials file
          mkdir -p ~/.cloudflared
          echo "$TUNNEL_TOKEN" > ~/.cloudflared/tunnel-token.json

          # Start named tunnel
          cloudflared tunnel --credentials-file ~/.cloudflared/tunnel-token.json run gitops-demo > /tmp/cf-dashboard.log 2>&1 &
          sleep 10

          echo ""
          echo "================================================"
          echo "üåê LIVE DASHBOARD URL:"
          echo "================================================"
          echo "https://gitops-infra.neevs.io"
          echo "================================================"
          echo ""
          echo "‚è∞ Dashboard will remain open for 15 minutes"
          echo "   Watch your GitOps deployment in real-time!"
          echo ""

          # Keep tunnel alive
          sleep 900  # 15 minutes

      - name: üìä Final status
        if: always()
        run: |
          echo "=== Final Status ==="
          argocd app list || true
          kubectl get all -n ml-inference || true
          echo "‚úÖ Dashboard session complete"

  # Job 5: Generate report (depends on all jobs, always runs)
  report:
    name: üìä Generate Final Report
    runs-on: ubuntu-22.04
    timeout-minutes: 5
    needs: [build, deploy, test, demo, dashboard]
    if: always()

    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì• Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: /tmp/artifacts/

      - name: üìä Generate demo report
        run: |
          mkdir -p /tmp/final-report

          cat > /tmp/final-report/DEMO-REPORT.md << 'EOFF'
          # GitOps Infrastructure Demo Report

          ## üéØ Demonstration Summary

          This workflow successfully demonstrated:

          - ‚úÖ **Docker Build & Push** - ML inference image built and pushed to GHCR
          - ‚úÖ **ArgoCD GitOps deployment** - Declarative, Git-driven infrastructure
          - ‚úÖ **Kubernetes orchestration** - Multi-service deployment on Minikube
          - ‚úÖ **ML Model Serving** - FastAPI inference service with sentiment analysis
          - ‚úÖ **Observability Stack** - VictoriaMetrics and Grafana for monitoring
          - ‚úÖ **Health checks** - All services passed liveness and readiness probes
          - ‚úÖ **Self-healing** - ArgoCD automatic drift detection and correction

          ## üìà Workflow Results

          EOFF

          # Add build status
          echo "### Build Status" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Build job: ${{ needs.build.result }}" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Deploy job: ${{ needs.deploy.result }}" >> /tmp/final-report/DEMO-REPORT.md
          echo "- Test job: ${{ needs.test.result }}" >> /tmp/final-report/DEMO-REPORT.md

          # Add timing information
          cat >> /tmp/final-report/DEMO-REPORT.md << 'EOFF'

          ## üöÄ Key Takeaways

          1. **Parallelized Workflow**: Build, test, and demo jobs run efficiently
          2. **GitOps in Action**: All deployments managed through Git with ArgoCD
          3. **Production Patterns**: Health checks, resource limits, auto-scaling ready
          4. **Observable**: VictoriaMetrics metrics, application logs, K8s events
          5. **Self-healing**: Demonstrated automatic drift correction
          6. **Zero Cost**: Entire demo runs in GitHub Actions (no cloud account needed)

          ## üìä Architecture

          ```
          GitHub Actions Workflow
          ‚îÇ
          ‚îú‚îÄ‚îÄ Job 1: Build (üèóÔ∏è)
          ‚îÇ   ‚îî‚îÄ‚îÄ Docker image ‚Üí GHCR
          ‚îÇ
          ‚îú‚îÄ‚îÄ Job 2: Deploy (üöÄ) [depends on Build]
          ‚îÇ   ‚îú‚îÄ‚îÄ Minikube cluster
          ‚îÇ   ‚îú‚îÄ‚îÄ ArgoCD installation
          ‚îÇ   ‚îî‚îÄ‚îÄ Application deployment
          ‚îÇ
          ‚îú‚îÄ‚îÄ Job 3a: Test (üß™) [parallel, depends on Deploy]
          ‚îÇ   ‚îî‚îÄ‚îÄ Health checks & API tests
          ‚îÇ
          ‚îú‚îÄ‚îÄ Job 3b: Demo (üé≠) [parallel, depends on Deploy]
          ‚îÇ   ‚îî‚îÄ‚îÄ GitOps self-healing demo
          ‚îÇ
          ‚îî‚îÄ‚îÄ Job 4: Report (üìä) [depends on all]
              ‚îî‚îÄ‚îÄ Aggregate results & artifacts
          ```

          ## üí° Technologies Demonstrated

          - **GitOps**: ArgoCD for declarative deployments
          - **Kubernetes**: Container orchestration
          - **CI/CD**: GitHub Actions with job parallelization
          - **ML Ops**: FastAPI model serving
          - **Observability**: VictoriaMetrics + Grafana
          - **Python**: FastAPI application
          - **Docker**: Container packaging & GHCR

          ---

          **Duration**: ~10-15 minutes (with parallelization)
          **Cost**: $0 (GitHub Actions free tier)
          **Reproducible**: ‚úÖ Anyone can run this workflow
          EOFF

          cat /tmp/final-report/DEMO-REPORT.md

      - name: üì§ Upload final report
        uses: actions/upload-artifact@v4
        with:
          name: final-demo-report
          path: /tmp/final-report/
          retention-days: 30

      - name: üìù Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('/tmp/final-report/DEMO-REPORT.md', 'utf8');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## GitOps Demo Results\n\n${report}\n\n[View full artifacts](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
            });

      - name: ‚úÖ Report complete
        run: |
          echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
          echo "‚ïë                                            ‚ïë"
          echo "‚ïë   ‚úÖ GitOps Infrastructure Demo Complete   ‚ïë"
          echo "‚ïë                                            ‚ïë"
          echo "‚ïë   Workflow Summary:                        ‚ïë"
          echo "‚ïë   ‚Ä¢ Build: ${{ needs.build.result }}"
          echo "‚ïë   ‚Ä¢ Deploy: ${{ needs.deploy.result }}"
          echo "‚ïë   ‚Ä¢ Test: ${{ needs.test.result }}"
          echo "‚ïë                                            ‚ïë"
          echo "‚ïë   Download artifacts for full details      ‚ïë"
          echo "‚ïë                                            ‚ïë"
          echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
